{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"vcfstats - powerful statistics for VCF files [ ] 10 [ ] 10 Documentation | CHANGELOG Motivation There are a couple of tools that can plot some statistics of VCF files, including bcftools and jvarkit . However, none of them could: 1. plot specific metrics 2. customize the plots 3. focus on variants with certain filters R package vcfR can do some of the above. However, it has to load entire VCF into memory, which is not friendly to large VCF files. Installation pip install -U vcfstats Or run with docker or singularity: docker run --rm justold/vcfstats:latest vcfstats # or singularity run docker://justold/vcfstats:latest vcfstats Gallery Number of variants on each chromosome vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1) ~ CONTIG' \\ --title 'Number of variants on each chromosome' \\ --config examples/config.toml Changing labels and ticks vcfstats uses plotnine for plotting, read more about it on how to specify --ggs to modify the plots. vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1) ~ CONTIG' \\ --title 'Number of variants on each chromosome (modified)' \\ --config examples/config.toml \\ --ggs 'scale_x_discrete(name =\"Chromosome\", \\ limits=[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"X\"]); \\ ylab(\"# Variants\")' Number of variants on first 5 chromosome vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1) ~ CONTIG[1,2,3,4,5]' \\ --title 'Number of variants on each chromosome (first 5)' \\ --config examples/config.toml # or vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1) ~ CONTIG[1-5]' \\ --title 'Number of variants on each chromosome (first 5)' \\ --config examples/config.toml # or # require vcf file to be tabix-indexed. vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1) ~ CONTIG' \\ --title 'Number of variants on each chromosome (first 5)' \\ --config examples/config.toml -r 1 2 3 4 5 Number of substitutions of SNPs vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1, VARTYPE[snp]) ~ SUBST[A>T,A>G,A>C,T>A,T>G,T>C,G>A,G>T,G>C,C>A,C>T,C>G]' \\ --title 'Number of substitutions of SNPs' \\ --config examples/config.toml Only with SNPs PASS all filters vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1, VARTYPE[snp]) ~ SUBST[A>T,A>G,A>C,T>A,T>G,T>C,G>A,G>T,G>C,C>A,C>T,C>G]' \\ --title 'Number of substitutions of SNPs (passed)' \\ --config examples/config.toml \\ --passed Alternative allele frequency on each chromosome # using a dark theme vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'AAF ~ CONTIG' \\ --title 'Allele frequency on each chromosome' \\ --config examples/config.toml --ggs 'theme_dark()' Using boxplot vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'AAF ~ CONTIG' \\ --title 'Allele frequency on each chromosome (boxplot)' \\ --config examples/config.toml \\ --figtype boxplot Using density plot/histogram to investigate the distribution: You can plot the distribution, using density plot or histogram vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'AAF ~ CONTIG[1,2]' \\ --title 'Allele frequency on chromosome 1,2' \\ --config examples/config.toml \\ --figtype density Overall distribution of allele frequency vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'AAF ~ 1' \\ --title 'Overall allele frequency distribution' \\ --config examples/config.toml Excluding some low/high frequency variants vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'AAF[0.05, 0.95] ~ 1' \\ --title 'Overall allele frequency distribution (0.05-0.95)' \\ --config examples/config.toml Counting types of variants on each chromosome vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1, group=VARTYPE) ~ CHROM' \\ # or simply # --formula 'VARTYPE ~ CHROM' \\ --title 'Types of variants on each chromosome' \\ --config examples/config.toml Using bar chart if there is only one chromosome vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1, group=VARTYPE) ~ CHROM[1]' \\ # or simply # --formula 'VARTYPE ~ CHROM[1]' \\ --title 'Types of variants on chromosome 1' \\ --config examples/config.toml \\ --figtype pie Counting variant types on whole genome vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ # or simply # --formula 'VARTYPE ~ 1' \\ --formula 'COUNT(1, group=VARTYPE) ~ 1' \\ --title 'Types of variants on whole genome' \\ --config examples/config.toml Counting type of mutant genotypes (HET, HOM_ALT) for sample 1 on each chromosome vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ # or simply # --formula 'GTTYPEs[HET,HOM_ALT]{0} ~ CHROM' \\ --formula 'COUNT(1, group=GTTYPEs[HET,HOM_ALT]{0}) ~ CHROM' \\ --title 'Mutant genotypes on each chromosome (sample 1)' \\ --config examples/config.toml Exploration of mean(genotype quality) and mean(depth) on each chromosome for sample 1 vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'MEAN(GQs{0}) ~ MEAN(DEPTHs{0}, group=CHROM)' \\ --title 'GQ vs depth (sample 1)' \\ --config examples/config.toml Exploration of depths for sample 1,2 vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'DEPTHs{0} ~ DEPTHs{1}' \\ --title 'Depths between sample 1 and 2' \\ --config examples/config.toml See more examples: https://github.com/pwwang/vcfstats/issues/15#issuecomment-1029367903","title":"Introduction"},{"location":"#vcfstats-powerful-statistics-for-vcf-files","text":"[ ] 10 [ ] 10 Documentation | CHANGELOG","title":"vcfstats - powerful statistics for VCF files"},{"location":"#motivation","text":"There are a couple of tools that can plot some statistics of VCF files, including bcftools and jvarkit . However, none of them could: 1. plot specific metrics 2. customize the plots 3. focus on variants with certain filters R package vcfR can do some of the above. However, it has to load entire VCF into memory, which is not friendly to large VCF files.","title":"Motivation"},{"location":"#installation","text":"pip install -U vcfstats Or run with docker or singularity: docker run --rm justold/vcfstats:latest vcfstats # or singularity run docker://justold/vcfstats:latest vcfstats","title":"Installation"},{"location":"#gallery","text":"","title":"Gallery"},{"location":"#number-of-variants-on-each-chromosome","text":"vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1) ~ CONTIG' \\ --title 'Number of variants on each chromosome' \\ --config examples/config.toml","title":"Number of variants on each chromosome"},{"location":"#changing-labels-and-ticks","text":"vcfstats uses plotnine for plotting, read more about it on how to specify --ggs to modify the plots. vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1) ~ CONTIG' \\ --title 'Number of variants on each chromosome (modified)' \\ --config examples/config.toml \\ --ggs 'scale_x_discrete(name =\"Chromosome\", \\ limits=[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"X\"]); \\ ylab(\"# Variants\")'","title":"Changing labels and ticks"},{"location":"#number-of-variants-on-first-5-chromosome","text":"vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1) ~ CONTIG[1,2,3,4,5]' \\ --title 'Number of variants on each chromosome (first 5)' \\ --config examples/config.toml # or vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1) ~ CONTIG[1-5]' \\ --title 'Number of variants on each chromosome (first 5)' \\ --config examples/config.toml # or # require vcf file to be tabix-indexed. vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1) ~ CONTIG' \\ --title 'Number of variants on each chromosome (first 5)' \\ --config examples/config.toml -r 1 2 3 4 5","title":"Number of variants on first 5 chromosome"},{"location":"#number-of-substitutions-of-snps","text":"vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1, VARTYPE[snp]) ~ SUBST[A>T,A>G,A>C,T>A,T>G,T>C,G>A,G>T,G>C,C>A,C>T,C>G]' \\ --title 'Number of substitutions of SNPs' \\ --config examples/config.toml","title":"Number of substitutions of SNPs"},{"location":"#only-with-snps-pass-all-filters","text":"vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1, VARTYPE[snp]) ~ SUBST[A>T,A>G,A>C,T>A,T>G,T>C,G>A,G>T,G>C,C>A,C>T,C>G]' \\ --title 'Number of substitutions of SNPs (passed)' \\ --config examples/config.toml \\ --passed","title":"Only with SNPs PASS all filters"},{"location":"#alternative-allele-frequency-on-each-chromosome","text":"# using a dark theme vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'AAF ~ CONTIG' \\ --title 'Allele frequency on each chromosome' \\ --config examples/config.toml --ggs 'theme_dark()'","title":"Alternative allele frequency on each chromosome"},{"location":"#using-boxplot","text":"vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'AAF ~ CONTIG' \\ --title 'Allele frequency on each chromosome (boxplot)' \\ --config examples/config.toml \\ --figtype boxplot","title":"Using boxplot"},{"location":"#using-density-plothistogram-to-investigate-the-distribution","text":"You can plot the distribution, using density plot or histogram vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'AAF ~ CONTIG[1,2]' \\ --title 'Allele frequency on chromosome 1,2' \\ --config examples/config.toml \\ --figtype density","title":"Using density plot/histogram to investigate the distribution:"},{"location":"#overall-distribution-of-allele-frequency","text":"vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'AAF ~ 1' \\ --title 'Overall allele frequency distribution' \\ --config examples/config.toml","title":"Overall distribution of allele frequency"},{"location":"#excluding-some-lowhigh-frequency-variants","text":"vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'AAF[0.05, 0.95] ~ 1' \\ --title 'Overall allele frequency distribution (0.05-0.95)' \\ --config examples/config.toml","title":"Excluding some low/high frequency variants"},{"location":"#counting-types-of-variants-on-each-chromosome","text":"vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1, group=VARTYPE) ~ CHROM' \\ # or simply # --formula 'VARTYPE ~ CHROM' \\ --title 'Types of variants on each chromosome' \\ --config examples/config.toml","title":"Counting types of variants on each chromosome"},{"location":"#using-bar-chart-if-there-is-only-one-chromosome","text":"vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'COUNT(1, group=VARTYPE) ~ CHROM[1]' \\ # or simply # --formula 'VARTYPE ~ CHROM[1]' \\ --title 'Types of variants on chromosome 1' \\ --config examples/config.toml \\ --figtype pie","title":"Using bar chart if there is only one chromosome"},{"location":"#counting-variant-types-on-whole-genome","text":"vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ # or simply # --formula 'VARTYPE ~ 1' \\ --formula 'COUNT(1, group=VARTYPE) ~ 1' \\ --title 'Types of variants on whole genome' \\ --config examples/config.toml","title":"Counting variant types on whole genome"},{"location":"#counting-type-of-mutant-genotypes-het-hom_alt-for-sample-1-on-each-chromosome","text":"vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ # or simply # --formula 'GTTYPEs[HET,HOM_ALT]{0} ~ CHROM' \\ --formula 'COUNT(1, group=GTTYPEs[HET,HOM_ALT]{0}) ~ CHROM' \\ --title 'Mutant genotypes on each chromosome (sample 1)' \\ --config examples/config.toml","title":"Counting type of mutant genotypes (HET, HOM_ALT) for sample 1 on each chromosome"},{"location":"#exploration-of-meangenotype-quality-and-meandepth-on-each-chromosome-for-sample-1","text":"vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'MEAN(GQs{0}) ~ MEAN(DEPTHs{0}, group=CHROM)' \\ --title 'GQ vs depth (sample 1)' \\ --config examples/config.toml","title":"Exploration of mean(genotype quality) and mean(depth) on each chromosome for sample 1"},{"location":"#exploration-of-depths-for-sample-12","text":"vcfstats --vcf examples/sample.vcf \\ --outdir examples/ \\ --formula 'DEPTHs{0} ~ DEPTHs{1}' \\ --title 'Depths between sample 1 and 2' \\ --config examples/config.toml See more examples: https://github.com/pwwang/vcfstats/issues/15#issuecomment-1029367903","title":"Exploration of depths for sample 1,2"},{"location":"CHANGELOG/","text":"0.4.1 \ud83d\udcdd Add more examples regarding #20 \ud83d\udc1b Fix devpars by default a Namespace rather than a dict (#21, #22) 0.4.0 \u2b06\ufe0f Drop support for python 3.8 (brentp/cyvcf2#181) \ud83d\udea8 Use python3.9 in Dockerfile \u2b06\ufe0f\ufe0f Upgrade pyparam to 0.5 \u2b06\ufe0f Upgrade and pin deps \ud83d\udcdd Add more examples (#15, #17) \ud83d\udc77 Add docker build in CI 0.3.0 Introduce enhancements (pwwang/vcfstats#15) 0.2.0 Use plotnine instead of ggplot2 so no R is needed Add figfmt to generate different format of figures other than png 0.1.0 Allow program to be run by python -m vcfstats Avoid using root logger configuration 0.0.6 Adopt latest pyparam 0.0.5 Adopt lastest cmdy 0.0.4 Add original formula in the error message if it is malformated Add warnings if failed to fetch sample depth for a variant Fix a bug when continuous filter has zero Other fixes 0.0.3 Fix CAT ~ CAT plots Use pie chart for CAT ~ 1 as default 0.0.2 Add tests and fix bugs 0.0.1 Implement basic functions","title":"Change log"},{"location":"CHANGELOG/#041","text":"\ud83d\udcdd Add more examples regarding #20 \ud83d\udc1b Fix devpars by default a Namespace rather than a dict (#21, #22)","title":"0.4.1"},{"location":"CHANGELOG/#040","text":"\u2b06\ufe0f Drop support for python 3.8 (brentp/cyvcf2#181) \ud83d\udea8 Use python3.9 in Dockerfile \u2b06\ufe0f\ufe0f Upgrade pyparam to 0.5 \u2b06\ufe0f Upgrade and pin deps \ud83d\udcdd Add more examples (#15, #17) \ud83d\udc77 Add docker build in CI","title":"0.4.0"},{"location":"CHANGELOG/#030","text":"Introduce enhancements (pwwang/vcfstats#15)","title":"0.3.0"},{"location":"CHANGELOG/#020","text":"Use plotnine instead of ggplot2 so no R is needed Add figfmt to generate different format of figures other than png","title":"0.2.0"},{"location":"CHANGELOG/#010","text":"Allow program to be run by python -m vcfstats Avoid using root logger configuration","title":"0.1.0"},{"location":"CHANGELOG/#006","text":"Adopt latest pyparam","title":"0.0.6"},{"location":"CHANGELOG/#005","text":"Adopt lastest cmdy","title":"0.0.5"},{"location":"CHANGELOG/#004","text":"Add original formula in the error message if it is malformated Add warnings if failed to fetch sample depth for a variant Fix a bug when continuous filter has zero Other fixes","title":"0.0.4"},{"location":"CHANGELOG/#003","text":"Fix CAT ~ CAT plots Use pie chart for CAT ~ 1 as default","title":"0.0.3"},{"location":"CHANGELOG/#002","text":"Add tests and fix bugs","title":"0.0.2"},{"location":"CHANGELOG/#001","text":"Implement basic functions","title":"0.0.1"},{"location":"cliargs/","text":"Command-line arguments DESCRIPTION: vcfstats v0.2.0: Powerful VCF statistics. USAGE: vcfstats --vcf PATH --outdir AUTO --formula LIST --title LIST [ OPTIONS ] REQUIRED OPTIONS: -v, --vcf <PATH> - The VCF file. -o, --outdir <AUTO> - The output directory. -f, --formula <LIST> - The formulas for plotting in format of Y ~ X, where Y and X should be either an entry or an aggregation. --title <LIST> - The title of each figure, will be used to name the output files as well. OPTIONAL OPTIONS: --loglevel <STR> - The logging level. Default: info --figtype <LIST> - Your preferences for type of plot for each formula. Default: \\[ ] --figfmt <LIST> - Your preferences for format of figure for each formula, Any file format supported by matplotlib. Default is png. Default: \\[ ] -r, --region <LIST> - Regions in format of CHR or CHR:START-END Default: \\[ ] -R, --Region <AUTO> - Regions in a BED file. If both --region/--Region are provided, regions will be merged together. Default: None -p, --passed [ BOOL ] - Only analyze variants that pass all filters. This does not work if FILTER entry is in the analysis. Default: False -l, --list [ BOOL ] - List all available macros. Default: False -s, --savedata [ BOOL ] - Whether save the plotting data for further exploration. Default: False --macro <PATH> - A user-defined macro file. Default: None --ggs <LIST> - Extra ggplot2 expressions for each plot Default: \\[ ] --devpars <NS> - The device parameters for plots. To specify devpars for each plot, use a configuration file. -c, --config <AUTO> - A configuration file defining how to plot in TOML format. If this is provided, CLI arguments will be overwritten if defined in this file. Default: None -h, --help - Print help information for this command OPTIONAL OPTIONS UNDER --devpars: --devpars.width <INT> - The width of the plot Default: 2000 --devpars.height <INT> - The height of the plot Default: 2000 --devpars.res <INT> - The resolution of the plot Default: 300 You can specify regions using -r/--region and/or -R/--Region , however, you have to make sure regions are not overlapping, otherwise, variants in the overlapping regions will be redundant in the calculations. To define you macros, you'd better use docstr , so that you can use -l/--list to check out your macros You can generate multiple plots in one run. Just specify multiple formulas and multiple titles. For example: vcfstats --vcf examples/sample.vcf \\ --outdir vcfstats-out \\ --formula 'DEPTHs{0} ~ CHROM' 'AAF ~ CHROM' \\ --title 'Depth distribution on each chromosome' 'Allele frequency distribution on each chromosome' You can also specify different figure types for different plots. If you want to keep ones as default, you can pass an empty string. For example: vcfstats --vcf examples/sample.vcf \\ --outdir vcfstats-out \\ --formula 'DEPTHs{0} ~ CHROM' 'AAF ~ CHROM' \\ --title 'Depth distribution on each chromosome' 'Allele frequency distribution on each chromosome' \\ --figtype '' boxplot # using boxplot instead of violin for 2nd plot Similar as --figtype , you can also use --ggs to modify the plots generated by ggplot2 . Please refer to ggplot2 documentation. However, for --devpars , you can only specify a universal parameters. To change each sub-parameter of it, you can do --devpars.res 70 To specify different devpars for different plots, you have to use a configuration file. Please refer to seciont Configuration file To specify --ggs for multiple plots, you can do --ggs \"theme_minimal()\" \"theme_dark()\" . If you have multiple ggs for the same plot, you need ; to seaprate them: --ggs \"theme_minimal(); ylab('Count')\" \"theme_dark(); xlab('ABC')\"","title":"Command-line arguments"},{"location":"cliargs/#command-line-arguments","text":"DESCRIPTION: vcfstats v0.2.0: Powerful VCF statistics. USAGE: vcfstats --vcf PATH --outdir AUTO --formula LIST --title LIST [ OPTIONS ] REQUIRED OPTIONS: -v, --vcf <PATH> - The VCF file. -o, --outdir <AUTO> - The output directory. -f, --formula <LIST> - The formulas for plotting in format of Y ~ X, where Y and X should be either an entry or an aggregation. --title <LIST> - The title of each figure, will be used to name the output files as well. OPTIONAL OPTIONS: --loglevel <STR> - The logging level. Default: info --figtype <LIST> - Your preferences for type of plot for each formula. Default: \\[ ] --figfmt <LIST> - Your preferences for format of figure for each formula, Any file format supported by matplotlib. Default is png. Default: \\[ ] -r, --region <LIST> - Regions in format of CHR or CHR:START-END Default: \\[ ] -R, --Region <AUTO> - Regions in a BED file. If both --region/--Region are provided, regions will be merged together. Default: None -p, --passed [ BOOL ] - Only analyze variants that pass all filters. This does not work if FILTER entry is in the analysis. Default: False -l, --list [ BOOL ] - List all available macros. Default: False -s, --savedata [ BOOL ] - Whether save the plotting data for further exploration. Default: False --macro <PATH> - A user-defined macro file. Default: None --ggs <LIST> - Extra ggplot2 expressions for each plot Default: \\[ ] --devpars <NS> - The device parameters for plots. To specify devpars for each plot, use a configuration file. -c, --config <AUTO> - A configuration file defining how to plot in TOML format. If this is provided, CLI arguments will be overwritten if defined in this file. Default: None -h, --help - Print help information for this command OPTIONAL OPTIONS UNDER --devpars: --devpars.width <INT> - The width of the plot Default: 2000 --devpars.height <INT> - The height of the plot Default: 2000 --devpars.res <INT> - The resolution of the plot Default: 300 You can specify regions using -r/--region and/or -R/--Region , however, you have to make sure regions are not overlapping, otherwise, variants in the overlapping regions will be redundant in the calculations. To define you macros, you'd better use docstr , so that you can use -l/--list to check out your macros You can generate multiple plots in one run. Just specify multiple formulas and multiple titles. For example: vcfstats --vcf examples/sample.vcf \\ --outdir vcfstats-out \\ --formula 'DEPTHs{0} ~ CHROM' 'AAF ~ CHROM' \\ --title 'Depth distribution on each chromosome' 'Allele frequency distribution on each chromosome' You can also specify different figure types for different plots. If you want to keep ones as default, you can pass an empty string. For example: vcfstats --vcf examples/sample.vcf \\ --outdir vcfstats-out \\ --formula 'DEPTHs{0} ~ CHROM' 'AAF ~ CHROM' \\ --title 'Depth distribution on each chromosome' 'Allele frequency distribution on each chromosome' \\ --figtype '' boxplot # using boxplot instead of violin for 2nd plot Similar as --figtype , you can also use --ggs to modify the plots generated by ggplot2 . Please refer to ggplot2 documentation. However, for --devpars , you can only specify a universal parameters. To change each sub-parameter of it, you can do --devpars.res 70 To specify different devpars for different plots, you have to use a configuration file. Please refer to seciont Configuration file To specify --ggs for multiple plots, you can do --ggs \"theme_minimal()\" \"theme_dark()\" . If you have multiple ggs for the same plot, you need ; to seaprate them: --ggs \"theme_minimal(); ylab('Count')\" \"theme_dark(); xlab('ABC')\"","title":"Command-line arguments"},{"location":"configfile/","text":"Configuration file We are using toml file as configuration file. Please refer to its documentation . To overwrite arguments from command line, just specify the values directly in the configuration file. For example: devpars = { width = 1000 , height = 1000 , res = 100 } passed = true To specify multiple plots, we do: passed = true [[instance]] formula = 'DEPTHs{0} ~ CHROM' title = 'Depth distribution on each chromosome' ggs = 'theme_minimal()' devpars = { width = 1000 , height = 1000 , res = 100 } [[instance]] formula = 'AAF ~ CHROM' title = 'Allele frequency distribution on each chromosome' ggs = 'theme_bw()' devpars = { width = 2000 , height = 2000 , res = 300 }","title":"Configuration file"},{"location":"configfile/#configuration-file","text":"We are using toml file as configuration file. Please refer to its documentation . To overwrite arguments from command line, just specify the values directly in the configuration file. For example: devpars = { width = 1000 , height = 1000 , res = 100 } passed = true To specify multiple plots, we do: passed = true [[instance]] formula = 'DEPTHs{0} ~ CHROM' title = 'Depth distribution on each chromosome' ggs = 'theme_minimal()' devpars = { width = 1000 , height = 1000 , res = 100 } [[instance]] formula = 'AAF ~ CHROM' title = 'Allele frequency distribution on each chromosome' ggs = 'theme_bw()' devpars = { width = 2000 , height = 2000 , res = 300 }","title":"Configuration file"},{"location":"formulas/","text":"Formulas Formulas are composed of macros on both sides, which are connected by '~' . It looks like the formula syntax from R : Y ~ X . This basically determines how the plots are generated. However, we don't support operators like it from R . So we only have Y ~ X , but not Y ~ X1 + X2 . In order to implement this, we have to define a macro to add X1 and X2 up. We have three types of macros: continuous : extracts continues values from a variant, such as allele frequency, depth, etc. categorical : extracts categorical values from a variant, such as variant type, genotype, etc. aggregation : aggregates some values from a group of variants, such as mean of allele frequency from chromosome 1. You can also add a filter to aggregation by COUNT(1, filter=AAF[0.05, 0.95], group=CHROM) See section Macros for details. Tip If you have both aggregations for Y and X, you can omit the group for either. The one without group will automatically use the group that is specified to the other one. Predefined figure types for different combination of Y and X Y X default figure type other available figure types aggregation aggregation scatter - aggregation categorical col pie aggregation 1 pie col anything other than aggregation aggregation not available - categorical categorical bar pie continuous categorical voilin boxplot/histogram/density/freqpoly categorical 1 pie bar categorical continuous (not 1) not available - continueous continuous scatter - geom s from ggplot2 used to plot for different figure types figure type geom scatter geom_point col geom_col pie geom_col with coord_polar bar geom_bar violin geom_violin boxplot geom_boxplot density geom_density freqpoly geom_freqpoly","title":"Formulas"},{"location":"formulas/#formulas","text":"Formulas are composed of macros on both sides, which are connected by '~' . It looks like the formula syntax from R : Y ~ X . This basically determines how the plots are generated. However, we don't support operators like it from R . So we only have Y ~ X , but not Y ~ X1 + X2 . In order to implement this, we have to define a macro to add X1 and X2 up. We have three types of macros: continuous : extracts continues values from a variant, such as allele frequency, depth, etc. categorical : extracts categorical values from a variant, such as variant type, genotype, etc. aggregation : aggregates some values from a group of variants, such as mean of allele frequency from chromosome 1. You can also add a filter to aggregation by COUNT(1, filter=AAF[0.05, 0.95], group=CHROM) See section Macros for details. Tip If you have both aggregations for Y and X, you can omit the group for either. The one without group will automatically use the group that is specified to the other one.","title":"Formulas"},{"location":"formulas/#predefined-figure-types-for-different-combination-of-y-and-x","text":"Y X default figure type other available figure types aggregation aggregation scatter - aggregation categorical col pie aggregation 1 pie col anything other than aggregation aggregation not available - categorical categorical bar pie continuous categorical voilin boxplot/histogram/density/freqpoly categorical 1 pie bar categorical continuous (not 1) not available - continueous continuous scatter -","title":"Predefined figure types for different combination of Y and X"},{"location":"formulas/#geoms-from-ggplot2-used-to-plot-for-different-figure-types","text":"figure type geom scatter geom_point col geom_col pie geom_col with coord_polar bar geom_bar violin geom_violin boxplot geom_boxplot density geom_density freqpoly geom_freqpoly","title":"geoms from ggplot2 used to plot for different figure types"},{"location":"macros/","text":"Macros Macros are used to gather some information from variants. They are nothing but just python function with our decorators. To define a macro: from vcfstats.macros import continuous @continuous def QUAL ( variant ): return variant . QUAL We are using cyvcf2 to get variant information, please refer to its API documentation to explore what kind of metrics we can get from a variant. Note vcf is initialized with gts012 = True , which is not the default value of cyvcf2 . \\ gts012 = True indicates that genotype 2 as HOM_ALT and 3 as UNKNOWN . Shortcuts for macro decorators decrator shortcut continuous cont categorical cat aggregation aggr Macros other than aggregations with sample data If a macro returns sample data, we need to return a list or numpy.array with data for each sample. In the formula, we have to use brackets to get the information of certain sample. For example: from vcf.macros import cat @cat def GTTYPEs ( variant ) gttypes = variant . gt_types return [ 'HOM_REF' if gttype == 0 else \\ 'HET' if gttype == 1 else \\ 'HOM_ALT' if gttype == 2 else 'UNKNOWN' for gttype in gttypes ] To get the genotype in sample 1 in formula: GTTYPEs{0} . You can also use sample name as well: GTTYPEs{some sample} Macros with filters aggregation s have different syntax for filters. Here we are discussing about continuous and categorical . For continuous macros, we can use an upper and lower bound to filter. For example: AAF[0.05, 0.95] will take only variants with alternate allele frequency within [0.05, 0.95] , including 0.05 and 0.95 . We don't have a lower/upper bound exclusive syntax, so to exclude 0.05 , we can specify some value less than and close to it, say 0.0499 . For categorical macros, we can specify the categories that we want to keep in the plotting. For example: CHROM[chr1, chr2, chr3] . More conveniently, we can use hyphen to include a range of categories. For example, CHROM[chr1-chr22, chrX, chrY] will include all human chromosomes. Hint With both filters and sample subscribes, it doesn't matter which one you put it first. That means you can do both GTTYPEs{0}[HET] and GTTYPEs[HET]{0} . They are the same. Aggregations When you define aggregations, you just define who to aggregate the values. For example: from vcfstats.macros import aggr @aggr def SUM ( values ): return sum ( values ) While when you use it, you can specify macros as filter and group for it. For example: SUM(DEPTHs{0}, filter=FILTER[PASS], group=CHROM) . This means to sum up the depth of variants pass all filters on each chromosome for the first sample. Note Generally, we have to specify group for an aggregation. There are 2 situations that you don't have to: when an aggregation is used as Y , left part of the formula, and X is a categorical macro. Then the categorical values will be used as group for the aggregation. both X and Y are aggregations and one of them can have no group and will use the group from the other one. Built-in macros @categorical def VARTYPE ( variant ): \"\"\"Variant type, one of deletion, indel, snp or sv\"\"\" return variant . var_type @categorical def TITV ( variant ): \"\"\"Tell if a variant is a transition or transversion. The variant has to be an snp first.\"\"\" if not variant . is_snp : return False return 'transition' if variant . is_transition else 'transversion' @categorical ( alias = 'CHROM' ) def CONTIG ( variant ): \"\"\"Get the config/chromosome of a variant. Alias: CHROM\"\"\" return variant . CHROM @categorical ( alias = 'GT_TYPEs' ) def GTTYPEs ( variant ): \"\"\"Get the genotypes(HOM_REF,HET,HOM_ALT,UNKNOWN) of a variant for each sample\"\"\" gttypes = variant . gt_types return [ 'HOM_REF' if gttype == 0 else \\ 'HET' if gttype == 1 else \\ 'HOM_ALT' if gttype == 2 else 'UNKNOWN' for gttype in gttypes ] @categorical def FILTER ( variant ): \"\"\"Get the FILTER of a variant.\"\"\" return variant . FILTER or 'PASS' @categorical def SUBST ( variant ): \"\"\"Substitution of the variant, including all types of varinat\"\"\" return ' {} > {} ' . format ( variant . REF , ',' . join ( variant . ALT )) @continuous def NALT ( variant ): \"\"\"Number of alternative alleles\"\"\" return len ( variant . ALT ) @continuous def GQs ( variant ): \"\"\"get the GQ for each sample as a numpy array.\"\"\" return variant . gt_quals @continuous def QUAL ( variant ): \"\"\"Variant quality from QUAL field.\"\"\" return variant . QUAL @continuous ( alias = 'DPs' ) def DEPTHs ( variant ): \"\"\"Get the read-depth for each sample as a numpy array.\"\"\" return [ sum ( dp ) for dp in variant . format ( 'DP' )] @continuous def AAF ( variant ): \"\"\"Alternate allele frequency across samples in this VCF.\"\"\" return variant . aaf @continuous def AFs ( variant ): \"\"\"get the freq of alternate reads as a numpy array.\"\"\" return variant . gt_alt_freqs @continuous def _ONE ( variant ): \"\"\"Return 1 for a variant, usually used in aggregation, or indication of a distribution plot\"\"\" return 1 @aggregation def COUNT ( entries ): \"\"\"Count the variants in groups\"\"\" return len ( entries ) @aggregation def SUM ( entries ): \"\"\"Sum up the values in groups\"\"\" return sum ( entries ) @aggregation ( alias = 'AVG' ) def MEAN ( entries ): \"\"\"Get the mean of the values\"\"\" if not entries : return 0.0 return sum ( entries ) / len ( entries )","title":"Macros"},{"location":"macros/#macros","text":"Macros are used to gather some information from variants. They are nothing but just python function with our decorators. To define a macro: from vcfstats.macros import continuous @continuous def QUAL ( variant ): return variant . QUAL We are using cyvcf2 to get variant information, please refer to its API documentation to explore what kind of metrics we can get from a variant. Note vcf is initialized with gts012 = True , which is not the default value of cyvcf2 . \\ gts012 = True indicates that genotype 2 as HOM_ALT and 3 as UNKNOWN .","title":"Macros"},{"location":"macros/#shortcuts-for-macro-decorators","text":"decrator shortcut continuous cont categorical cat aggregation aggr","title":"Shortcuts for macro decorators"},{"location":"macros/#macros-other-than-aggregations-with-sample-data","text":"If a macro returns sample data, we need to return a list or numpy.array with data for each sample. In the formula, we have to use brackets to get the information of certain sample. For example: from vcf.macros import cat @cat def GTTYPEs ( variant ) gttypes = variant . gt_types return [ 'HOM_REF' if gttype == 0 else \\ 'HET' if gttype == 1 else \\ 'HOM_ALT' if gttype == 2 else 'UNKNOWN' for gttype in gttypes ] To get the genotype in sample 1 in formula: GTTYPEs{0} . You can also use sample name as well: GTTYPEs{some sample}","title":"Macros other than aggregations with sample data"},{"location":"macros/#macros-with-filters","text":"aggregation s have different syntax for filters. Here we are discussing about continuous and categorical . For continuous macros, we can use an upper and lower bound to filter. For example: AAF[0.05, 0.95] will take only variants with alternate allele frequency within [0.05, 0.95] , including 0.05 and 0.95 . We don't have a lower/upper bound exclusive syntax, so to exclude 0.05 , we can specify some value less than and close to it, say 0.0499 . For categorical macros, we can specify the categories that we want to keep in the plotting. For example: CHROM[chr1, chr2, chr3] . More conveniently, we can use hyphen to include a range of categories. For example, CHROM[chr1-chr22, chrX, chrY] will include all human chromosomes. Hint With both filters and sample subscribes, it doesn't matter which one you put it first. That means you can do both GTTYPEs{0}[HET] and GTTYPEs[HET]{0} . They are the same.","title":"Macros with filters"},{"location":"macros/#aggregations","text":"When you define aggregations, you just define who to aggregate the values. For example: from vcfstats.macros import aggr @aggr def SUM ( values ): return sum ( values ) While when you use it, you can specify macros as filter and group for it. For example: SUM(DEPTHs{0}, filter=FILTER[PASS], group=CHROM) . This means to sum up the depth of variants pass all filters on each chromosome for the first sample. Note Generally, we have to specify group for an aggregation. There are 2 situations that you don't have to: when an aggregation is used as Y , left part of the formula, and X is a categorical macro. Then the categorical values will be used as group for the aggregation. both X and Y are aggregations and one of them can have no group and will use the group from the other one.","title":"Aggregations"},{"location":"macros/#built-in-macros","text":"@categorical def VARTYPE ( variant ): \"\"\"Variant type, one of deletion, indel, snp or sv\"\"\" return variant . var_type @categorical def TITV ( variant ): \"\"\"Tell if a variant is a transition or transversion. The variant has to be an snp first.\"\"\" if not variant . is_snp : return False return 'transition' if variant . is_transition else 'transversion' @categorical ( alias = 'CHROM' ) def CONTIG ( variant ): \"\"\"Get the config/chromosome of a variant. Alias: CHROM\"\"\" return variant . CHROM @categorical ( alias = 'GT_TYPEs' ) def GTTYPEs ( variant ): \"\"\"Get the genotypes(HOM_REF,HET,HOM_ALT,UNKNOWN) of a variant for each sample\"\"\" gttypes = variant . gt_types return [ 'HOM_REF' if gttype == 0 else \\ 'HET' if gttype == 1 else \\ 'HOM_ALT' if gttype == 2 else 'UNKNOWN' for gttype in gttypes ] @categorical def FILTER ( variant ): \"\"\"Get the FILTER of a variant.\"\"\" return variant . FILTER or 'PASS' @categorical def SUBST ( variant ): \"\"\"Substitution of the variant, including all types of varinat\"\"\" return ' {} > {} ' . format ( variant . REF , ',' . join ( variant . ALT )) @continuous def NALT ( variant ): \"\"\"Number of alternative alleles\"\"\" return len ( variant . ALT ) @continuous def GQs ( variant ): \"\"\"get the GQ for each sample as a numpy array.\"\"\" return variant . gt_quals @continuous def QUAL ( variant ): \"\"\"Variant quality from QUAL field.\"\"\" return variant . QUAL @continuous ( alias = 'DPs' ) def DEPTHs ( variant ): \"\"\"Get the read-depth for each sample as a numpy array.\"\"\" return [ sum ( dp ) for dp in variant . format ( 'DP' )] @continuous def AAF ( variant ): \"\"\"Alternate allele frequency across samples in this VCF.\"\"\" return variant . aaf @continuous def AFs ( variant ): \"\"\"get the freq of alternate reads as a numpy array.\"\"\" return variant . gt_alt_freqs @continuous def _ONE ( variant ): \"\"\"Return 1 for a variant, usually used in aggregation, or indication of a distribution plot\"\"\" return 1 @aggregation def COUNT ( entries ): \"\"\"Count the variants in groups\"\"\" return len ( entries ) @aggregation def SUM ( entries ): \"\"\"Sum up the values in groups\"\"\" return sum ( entries ) @aggregation ( alias = 'AVG' ) def MEAN ( entries ): \"\"\"Get the mean of the values\"\"\" if not entries : return 0.0 return sum ( entries ) / len ( entries )","title":"Built-in macros"}]}